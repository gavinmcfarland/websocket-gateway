<!DOCTYPE html>
<html>

<head>
	<title>Socket Client</title>
	<script src="/socket.io/socket.io.js"></script>
	<style>
		.room {
			margin-bottom: 20px;
		}

		.member {
			margin: 5px 0;
		}

		#messages {
			height: 200px;
			overflow-y: auto;
			border: 1px solid #ccc;
			padding: 10px;
			margin: 10px 0;
		}

		.message-containers {
			display: flex;
			gap: 20px;
		}

		.message-section {
			flex: 1;
		}

		.message-box {
			height: 200px;
			overflow-y: auto;
			border: 1px solid #ccc;
			padding: 10px;
			margin: 10px 0;
		}

		.sent-message {
			color: #0066cc;
		}

		.received-message {
			color: #006600;
		}
	</style>
</head>

<body>
	<h1 id="clientTitle">Socket Client</h1>
	<div id="clientId"></div>

	<h2>Connected Clients</h2>
	<div id="rooms"></div>

	<div class="message-containers">
		<div class="message-section">
			<h2>Sent Messages</h2>
			<div id="sentMessages" class="message-box"></div>
		</div>
		<div class="message-section">
			<h2>Received Messages</h2>
			<div id="receivedMessages" class="message-box"></div>
		</div>
	</div>

	<input type="text" id="messageInput" placeholder="Type a message">
	<select id="room">
		<option value="browser">Browser</option>
		<option value="figma">Figma</option>
	</select>
	<button onclick="sendMessage()">Send Message</button>

	<script type="module">
		// Import the client factory
		import { createClient } from 'websocket-gateway';

		// Get client type from URL parameter (e.g., ?type=browser or ?type=figma)
		const urlParams = new URLSearchParams(window.location.search);
		const room = urlParams.get('type') || 'browser';

		// Update title based on client type
		document.getElementById('clientTitle').textContent = `${room.charAt(0).toUpperCase() + room.slice(1)} Client`;
		document.title = `${room.charAt(0).toUpperCase() + room.slice(1)} Client`;

		// Set default target type based on client type
		const roomSelect = document.getElementById('room');
		const options = roomSelect.options;
		for (let i = 0; i < options.length; i++) {
			if (options[i].value !== room) {
				options[i].selected = true;
				break;
			}
		}

		const socket = createClient({
			room,
			port: 8080  // Hardcode port or get from environment
		});

		socket.on('connect', () => {
			console.log('Connected as:', socket.id);
			document.getElementById('clientId').textContent = `Connected as: ${socket.id} in room: ${room}`;
		});

		// Update to use consistent event names from tests
		if (room === 'figma') {
			socket.on('ANY_EVENT', (data) => {
				if (data.content && data.content.type === 'FILE_CHANGED') {
					const changeData = data.content;

					// Forward using consistent event name
					socket.emit('ANY_EVENT', {
						room: 'test',
						content: {
							type: 'FILE_CHANGE_COMPLETE',
							data: changeData
						}
					});

					// Add to sent messages display
					const sentMessagesDiv = document.getElementById('sentMessages');
					const timestamp = new Date().toLocaleTimeString();
					sentMessagesDiv.innerHTML += `
						<div class="sent-message">
							[${timestamp}] File change notification sent to test-client: ${JSON.stringify(changeData)}
						</div>
					`;
					sentMessagesDiv.scrollTop = sentMessagesDiv.scrollHeight;
				}
			});
		}

		// Update room state listener to match test patterns
		socket.on('ROOM_STATE', (rooms) => {
			const roomsDiv = document.getElementById('rooms');
			roomsDiv.innerHTML = '';

			Object.entries(rooms).forEach(([roomName, members]) => {
				const roomDiv = document.createElement('div');
				roomDiv.className = 'room';
				roomDiv.innerHTML = `
                    <h3>${roomName} (${members.length})</h3>
                    ${members.map(m => `
                        <div class="member">${m.id} (${m.room})</div>
                    `).join('')}
                `;
				roomsDiv.appendChild(roomDiv);
			});
		});

		// Update message handling to use ANY_EVENT
		socket.on('ANY_EVENT', (data) => {
			const receivedMessagesDiv = document.getElementById('receivedMessages');
			const timestamp = new Date().toLocaleTimeString();
			const messageText = typeof data.content === 'object' ? JSON.stringify(data.content) : data.content;
			receivedMessagesDiv.innerHTML += `
                <div class="received-message">
                    [${timestamp}] From ${data.from || 'unknown'}: ${messageText}
                </div>
            `;
			receivedMessagesDiv.scrollTop = receivedMessagesDiv.scrollHeight;
		});

		function sendMessage() {
			const message = document.getElementById('messageInput').value;
			const room = document.getElementById('room').value;

			if (message) {
				// Add message to sent messages
				const sentMessagesDiv = document.getElementById('sentMessages');
				const timestamp = new Date().toLocaleTimeString();
				sentMessagesDiv.innerHTML += `
                    <div class="sent-message">
                        [${timestamp}] To ${room}: ${message}
                    </div>
                `;
				sentMessagesDiv.scrollTop = sentMessagesDiv.scrollHeight;

				// Send using ANY_EVENT format from tests
				socket.emit('ANY_EVENT', {
					room,
					content: message
				});
				document.getElementById('messageInput').value = '';
			}
		}

		// Add enter key support for sending messages
		document.getElementById('messageInput').addEventListener('keypress', (e) => {
			if (e.key === 'Enter') {
				sendMessage();
			}
		});
	</script>
</body>

</html>