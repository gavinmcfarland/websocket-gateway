<!DOCTYPE html>
<html>

<head>
	<title>Socket Client</title>
	<script src="/socket.io/socket.io.js"></script>
	<style>
		.room {
			margin-bottom: 20px;
		}

		.member {
			margin: 5px 0;
		}

		#messages {
			height: 200px;
			overflow-y: auto;
			border: 1px solid #ccc;
			padding: 10px;
			margin: 10px 0;
		}

		.message-containers {
			display: flex;
			gap: 20px;
		}

		.message-section {
			flex: 1;
		}

		.message-box {
			height: 200px;
			overflow-y: auto;
			border: 1px solid #ccc;
			padding: 10px;
			margin: 10px 0;
		}

		.sent-message {
			color: #0066cc;
		}

		.received-message {
			color: #006600;
		}
	</style>
</head>

<body>
	<h1 id="clientTitle">Socket Client</h1>
	<div id="clientId"></div>

	<h2>Connected Clients</h2>
	<div id="rooms"></div>

	<div class="message-containers">
		<div class="message-section">
			<h2>Sent Messages</h2>
			<div id="sentMessages" class="message-box"></div>
		</div>
		<div class="message-section">
			<h2>Received Messages</h2>
			<div id="receivedMessages" class="message-box"></div>
		</div>
	</div>

	<input type="text" id="messageInput" placeholder="Type a message">
	<select id="targetType">
		<option value="browser">Browser</option>
		<option value="figma">Figma</option>
	</select>
	<button onclick="sendMessage()">Send Message</button>

	<script>
		// Get client type from URL parameter (e.g., ?type=browser or ?type=figma)
		const urlParams = new URLSearchParams(window.location.search);
		const clientType = urlParams.get('type') || 'browser';

		// Update title based on client type
		document.getElementById('clientTitle').textContent = `${clientType.charAt(0).toUpperCase() + clientType.slice(1)} Client`;
		document.title = `${clientType.charAt(0).toUpperCase() + clientType.slice(1)} Client`;

		// Set default target type based on client type
		const targetSelect = document.getElementById('targetType');
		const options = targetSelect.options;
		for (let i = 0; i < options.length; i++) {
			if (options[i].value !== clientType) {
				options[i].selected = true;
				break;
			}
		}

		const socket = io({
			auth: { source: clientType }
		});

		socket.on('connect', () => {
			document.getElementById('clientId').textContent = `Connected as: ${socket.id}`;
		});

		// Add new event listener for file change notifications from dev server
		if (clientType === 'figma') {
			socket.on('MESSAGE_TO_TYPE', (data) => {
				if (data.targetType === 'figma' && data.message.type === 'FILE_CHANGED') {
					const changeData = data.message;

					// Forward the file change notification to the test server
					socket.emit('MESSAGE_TO_TYPE', {
						targetType: 'test-client',
						message: JSON.stringify({
							type: 'FILE_CHANGE_COMPLETE',
							data: changeData
						})
					});

					// Add to sent messages display
					const sentMessagesDiv = document.getElementById('sentMessages');
					const timestamp = new Date().toLocaleTimeString();
					sentMessagesDiv.innerHTML += `
						<div class="sent-message">
							[${timestamp}] File change notification sent to browser: ${JSON.stringify(changeData)}
						</div>
					`;
					sentMessagesDiv.scrollTop = sentMessagesDiv.scrollHeight;
				}
			});
		}

		socket.on('ROOM_STATE', (rooms) => {
			const roomsDiv = document.getElementById('rooms');
			roomsDiv.innerHTML = '';

			Object.entries(rooms).forEach(([roomName, members]) => {
				const roomDiv = document.createElement('div');
				roomDiv.className = 'room';
				roomDiv.innerHTML = `
                    <h3>${roomName} (${members.length})</h3>
                    ${members.map(m => `
                        <div class="member">${m.id} (${m.clientType})</div>
                    `).join('')}
                `;
				roomsDiv.appendChild(roomDiv);
			});
		});

		socket.on('MESSAGE_FROM_TYPE', ({ fromType, message }) => {
			const receivedMessagesDiv = document.getElementById('receivedMessages');
			const timestamp = new Date().toLocaleTimeString();
			const messageText = typeof message === 'object' ? JSON.stringify(message) : message;
			receivedMessagesDiv.innerHTML += `
                <div class="received-message">
                    [${timestamp}] From ${fromType}: ${messageText}
                </div>
            `;
			receivedMessagesDiv.scrollTop = receivedMessagesDiv.scrollHeight;
		});

		function sendMessage() {
			const message = document.getElementById('messageInput').value;
			const targetType = document.getElementById('targetType').value;

			if (message) {
				// Add message to sent messages
				const sentMessagesDiv = document.getElementById('sentMessages');
				const timestamp = new Date().toLocaleTimeString();
				sentMessagesDiv.innerHTML += `
                    <div class="sent-message">
                        [${timestamp}] To ${targetType}: ${message}
                    </div>
                `;
				sentMessagesDiv.scrollTop = sentMessagesDiv.scrollHeight;

				// Send the message as a string
				socket.emit('MESSAGE_TO_TYPE', {
					targetType,
					message: message  // Make sure we're sending the string directly
				});
				document.getElementById('messageInput').value = '';
			}
		}

		// Add enter key support for sending messages
		document.getElementById('messageInput').addEventListener('keypress', (e) => {
			if (e.key === 'Enter') {
				sendMessage();
			}
		});
	</script>
</body>

</html>